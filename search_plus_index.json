{"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":" 目录 我的个人博客 Git-flow 之 前端协同开发代码管理方案 Html 锚点 http协议层 HTTP 缓存 详解 Hybrid webviewJavascriptBridge 外部页面打开自动跳转至App 版本问题 微前端 静态与动态 Javascript JS代码规范 Node npm 常用命令 npm私有库搭建及使用 创建并发布一个npm私有包 常见问题 Project VUE-PC端管理后台开发 中台开发前端架构 基于Vue的单页App 大屏可视化 React React快速开发文档及demo React 常见问题 Vue 从 0 到 1 的vue项目架构 反向代理 常见问题 预加载、懒加载在vue中的实现 webpack hash解析 人机验证整理 前端模式 功能 微信支付总结 单点登录 工具-安全-性能-调试 Arachni Atom Plugins charles undefined Gzip压缩 jenkins JSConsole js保存文件工具 Preformance Time Slicing YAPI 搭建 创建自己的脚手架 安全 CSRF攻击 XSS攻击 性能 性能优化 性能检测工具 小程序 小程序开发踩坑 微信公众号 微信小程序开发方案调研 基于web components的微前端系统 概念集合 正则表达式 问题集 powered by Gitbook该文件修订时间： 2020-03-23 10:55:07 "},"./":{"url":"./","title":"我的个人博客","keywords":"","body":"我的个人博客 技术/随笔/见闻/读书等等 powered by Gitbook该文件修订时间： 2019-03-08 12:56:57 "},"git-flow之前端协同开发代码管理方案.html":{"url":"git-flow之前端协同开发代码管理方案.html","title":"Git-flow 之 前端协同开发代码管理方案","keywords":"","body":"Git-flow 之 前端协同开发代码管理方案 powered by Gitbook该文件修订时间： 2019-06-28 17:16:13 "},"Html/":{"url":"Html/","title":"Html","keywords":"","body":"Html Html window document... powered by Gitbook该文件修订时间： 2019-04-23 17:17:16 "},"Html/锚点.html":{"url":"Html/锚点.html","title":"锚点","keywords":"","body":"锚点 作用 用于用户在访问html时定位到具体的某个段落 用于保存用户的阅读位置 const id = this.$route.query._anchor const offsetTop = this.$refs[id].offsetTop this.$nextTick(() => { document.body.scrollTop = document.documentElement.scrollTop = offsetTop }) powered by Gitbook该文件修订时间： 2019-04-18 17:16:19 "},"http协议层.html":{"url":"http协议层.html","title":"http协议层","keywords":"","body":"http协议层 应用层 表示层 会话层 传输层 网络层 链路层 物理层 powered by Gitbook该文件修订时间： 2019-09-17 16:05:09 "},"http缓存.html":{"url":"http缓存.html","title":"HTTP 缓存 详解","keywords":"","body":"HTTP 缓存 详解 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ https://imweb.io/topic/5795dcb6fb312541492eda8c 概述 html/图片等静态资源在浏览器里会有缓存。 缓存两大类 本地缓存 共享缓存 缓存几种机制 浏览器缓存(本地) 代理缓存(共享) 代理转发响应时,缓存代理会预先将资源的副本保存在代理服务器上，当代理下次再接受到对相同资源的请求时，就可以直接将缓存的资源作为响应返回，无需从源服务器获取资源。 网关缓存 类比代理缓存 CDN缓存 cdn节点存储资源，当再次请求到cdn时，可以直接返回缓存的资源。 反向代理缓存 类比代理缓存 负载均衡 类比代理缓存 本地缓存 本地缓存涉及的几个属性 强制缓存 cache-control pragma expires 协商缓存 last-modified / if-modified-since etags / if-none-match 本地缓存状态码的几种表现 200 OK (from memory cache) 直接使用本地缓存，存在内存里，当进程结束，清空缓存 200 OK (from disk cache) 直接使用本地缓存，存在磁盘里，当进程结束，不清空缓存 304 发起请求至后端判断是否使用本地缓存（Etag/Last-Modified），返回304则使用本地缓存。 cache-control 禁止缓存 缓存中不得存储任何关于客户端请求和服务端响应的内容 Cache-Control: no-store 强制确认缓存 本地有缓存保存，但不使用，每次发起请求至服务器进行协商缓存确认 Cache-Control: no-cache 私有缓存与公共缓存 \"public\" 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。 而 \"private\" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。 Cache-Control: private Cache-Control: public 缓存过期机制 资源能够被缓存（保持新鲜）的最大时间。max-age是距离请求发起的时间的秒数 Cache-Control: max-age=31536000 缓存验证确认 当使用了 \"must-revalidate\" 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。 Cache-Control: must-revalidate Pragma Pragma 是一个在 HTTP/1.0 中规定的通用首部，这个首部的效果依赖于不同的实现，所以在“请求-响应”链中可能会有不同的效果。它用来向后兼容只支持 HTTP/1.0 协议的缓存服务器，那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来。 Pragma: no-cache Expires Expires 响应头包含日期/时间， 即在此时候之后，响应过期。 无效的日期，比如 0, 代表着过去的日期，即该资源已经过期。 如果在Cache-Control响应头设置了 \"max-age\" 或者 \"s-max-age\" 指令，那么 Expires 头会被忽略。 Expires: Wed, 21 Oct 2015 07:28:00 GMT Etag / If-none-match ETagHTTP响应头是资源的特定版本的标识符。如果给定URL中的资源更改，则服务器生成新的Etag值。 因此Etags类似于指纹。 比较etags能快速确定此资源是否变化。 Etag由服务器生成并在响应头里返回给客户端 客户端就发送值为ETag的If-None-Match header字段 服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用（新鲜）。 Response Header ETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\" Last-Modified / If-Modified-Since Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比 ETag 要低，所以这是一个备用机制。包含有 If-Modified-Since 首部的条件请求会使用这个字段。 If-Modified-Since 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，而在 Last-Modified 首部中会带有上次修改时间。 Response Header Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT Request Header If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT 本地缓存使用流程图 问题 html文件的缓存 浏览器不会对html文件直接取本地缓存，会发送校验请求至服务器，若无修改，则返回304 cache-control与expires共存 cache-control设置了max-age时，expires会被覆盖 未设置max-age或者expires时，但有last-modified 此时会启用浏览器的启发式缓存过期策略，该策略下浏览器会根据last-modified计算过期时间，若未过期，则直接使用本地缓存，返回200 from cache 启发式缓存策略 在没有其他缓存过期策略的情况下，根据response中的Date与Last-Modified之前的差值，取10%作为缓存时间周期。 离线存储 manifest ServiceWorker-离线存储方案 http长缓存最佳实践 revving 技术 不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。 加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。 构建工具自动化添加静态资源版本号。 webpack/url-loader/file-loader/HtmlWebpackPlugin index.html文件不会使用强制缓存，能够使用协商缓存 index.html里添加缓存字段对静态资源的加载没有影响 powered by Gitbook该文件修订时间： 2019-09-19 19:37:00 "},"Hybrid/":{"url":"Hybrid/","title":"Hybrid","keywords":"","body":"Hybrid app混合开发经验、问题 ... powered by Gitbook该文件修订时间： 2019-04-23 17:17:51 "},"Hybrid/bridge.html":{"url":"Hybrid/bridge.html","title":"webviewJavascriptBridge","keywords":"","body":"webviewJavascriptBridge Call WebViewJavascriptBridge.callHandler('colorClick', data, function(dataFromOC) { alert(\"JS 调用了 OC 注册的 colorClick 方法\"); document.getElementById(\"returnValue\").value = dataFromOC; }) Rigster bridge.registerHanlder('testJavaScriptFunction',function(data,responseCallback){ // data 是 OC 传递过来的数据. // responseCallback 是 JS 调用完毕之后传递给 OC 的数据 alert(\"JS 被 OC 调用了.\"); responseCallback({data: \"js 的数据\",from : \"JS\"}); }) 问题 register的方法回调里必须为同步，不能为异步，否则只能被native端call一次，第二次就会失效 js registerHanlder时，传入的第二个参数 function里不能包含异步逻辑，如promise等 观察者模式前端重构bridge 使用promise代替回调 对一个事件可添加多次监听 powered by Gitbook该文件修订时间： 2019-04-26 17:49:23 "},"Hybrid/scheme路由.html":{"url":"Hybrid/scheme路由.html","title":"外部页面打开自动跳转至App","keywords":"","body":"外部页面打开自动跳转至App 页面加载时跳转至App指定scheme协议的路由，浏览器中会自动弹出是否跳转到App的提示。 微信中不能跳转，需提示用户在浏览器里打开 APP scheme路由 window.location.href = url app内直接跳转至指定路由原生页面 powered by Gitbook该文件修订时间： 2019-08-01 19:20:34 "},"Hybrid/版本问题.html":{"url":"Hybrid/版本问题.html","title":"版本问题","keywords":"","body":"版本问题 每当客户端大版本发布，经常会遇到很多h5在新老版本app里的兼容性问题： 修改旧版h5页面，跳转至app的新页面 修改旧版h5页面，调用新的jsbridge方法 修改jsbridge方法，导致新老版本jsbridge行为不一致 处理因为版本更新而导致的兼容性问题 获取版本号 通过navigator传入app当前版本号，h5正则捕获到版本号 针对不同的版本号做不同的逻辑处理。 使用manifest，在app端缓存h5的资源，做到h5的版本管理，并与app保持一致 powered by Gitbook该文件修订时间： 2019-08-20 18:24:59 "},"iconfont整理.html":{"url":"iconfont整理.html","title":"微前端","keywords":"","body":"微前端 框架： https://github.com/QxQstar/single-spa-vue https://github.com/CanopyTax/single-spa powered by Gitbook该文件修订时间： 2019-12-24 18:36:19 "},"import与require.html":{"url":"import与require.html","title":"静态与动态","keywords":"","body":"import与require的深入理解 静态与动态 import是静态结构，静态编译，编译时解析，编译时加载 import进来的模块是指向改模块的一个指针，改指针会在编译的时候定义，但是并不执行引进模块的代码。 import在语法上静态结构，只能在顶层进行导入和导出，而不能在嵌套语句中，而且import与export语句没有动态部分，没有变量等，使得我们在编译时就能确定导入与导出。 require是动态加载，运行时加载， require进来的模块是一个对象，改对象需要执行模块代码后得到，在运行时加载，动态的引进 require在语法上则是动态的结构，可以在任意位置进行导入导出，因而我们只能在运行的时候确定导入导出的模块。 循环加载问题 在commonjs与esm中都有循环加载问题，但处理方式不同。 commonjs，即require语法下，a,b模块循环require的情况下： a会执行到require语句时输出已执行部分的结果 执行b，此时有require a的时候获取的是a部分执行的结果，继续执行直至结束后输出b的执行结果并保存在缓存中 继续执行a的剩余代码直至结束，并把结果保存在缓存中。 后面所有的对a,b模块的require都直接取缓存中的结果对象，不在重新执行。 esm中，即循环import a,b模块的情况下： a执行发现import b语法，中断a的执行 执行b，发现import a语法， 将a模块的指针作为结果给b，继续执行b的代码直至结束。 继续执行a，b的指针作为结果给a，直至执行结束。 import a，b模块都只是获取了对应模块的指针，运行时才会执行对应模块代码。 powered by Gitbook该文件修订时间： 2020-02-11 11:16:22 "},"Javascript/":{"url":"Javascript/","title":"Javascript","keywords":"","body":"Javascript ES5 ES6 ... powered by Gitbook该文件修订时间： 2019-04-23 17:15:20 "},"Javascript/JS代码规范.html":{"url":"Javascript/JS代码规范.html","title":"JS代码规范","keywords":"","body":"JS代码规范 vue语言规范 npm install eslint-plugin-vue 在.eslintrc文件里添加 {\"extends\": \"plugin: vue/essential\"} Standard规范 包括npm、github等高科技公司都在用 查阅地址： https://standardjs.com/rules-zhcn.html npm install --save-dev eslint-config-standard eslint-plugin-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node 在.eslintrc文件里添加 {\"extends\": [\"plugin: vue/essential\",\"standard\"]} Airbnb规范 查阅地址： https://github.com/airbnb/javascript 总结 建议使用 vue standard，配合vscode开发工具：vscode里安装eslint插件，自动根据.eslintrc或package.json里eslintConfig配置信息对代码进行校验。 powered by Gitbook该文件修订时间： 2019-03-08 16:09:36 "},"Node/":{"url":"Node/","title":"Node","keywords":"","body":"Node Node ... powered by Gitbook该文件修订时间： 2019-04-23 17:39:36 "},"Node/npm常用命令.html":{"url":"Node/npm常用命令.html","title":"npm 常用命令","keywords":"","body":"npm 常用命令 安装node centos下 curl -sL https://rpm.nodesource.com/setup_12.0.0 | bash - 或者 sudo curl --silent --location https://rpm.nodesource.com/setup_12.x | bash - yum install -y nodejs 删除 yum remove nodejs npm -y 使用nvm安装 powered by Gitbook该文件修订时间： 2019-05-21 15:06:00 "},"Node/npm私有库搭建及使用.html":{"url":"Node/npm私有库搭建及使用.html","title":"npm私有库搭建及使用","keywords":"","body":"npm私有库搭建及使用 搭建 使用verdaccio工具搭建本地库 npm install -g verdaccio --unsafe-perm 使用pm2启动服务 npm install -g pm2 --unsafe-perm pm2 verdaccio pm2 start `which verdaccio` 停止进程 pm2 stop verdaccio 配置文件位置 /home/admin/.config/verdaccio/config.yaml 使用Docker运行verdaccio yum install -y docker service docker start docker pull verdaccio/verdaccio docker run -it --rm --name verdaccio -p 4873:4873 verdaccio/verdaccio ​ 后台运行 docker run -d ... 权限提升 sudo -i 自动同步私有库的更新内容到项目中 使用npm-check-updates包 npm install -g npm-check-updates ncu '/^@aiways/.*$/' npm install 禁止注册 在/home/admin/.config/verdaccio/config.yaml文件中设置maximum为-1 gitlab托管npm仓库包，并增量上传 powered by Gitbook该文件修订时间： 2019-05-30 11:11:03 "},"Node/创建并发布一个npm私有包.html":{"url":"Node/创建并发布一个npm私有包.html","title":"创建并发布一个npm私有包","keywords":"","body":"创建并发布一个npm私有包 切换本地npm仓库源为公司私有库 私有库源地址：http://npmjs.aiwaystack.com:4873 设置本地npm仓库地址 npm config set registry [registryUrl] 或者 直接修改.npmrc npm config edit registry = http://registry.npm.taobao.org 使用nrm工具进行切换 npm install -g nrm nrm add aiways http://registry.npmjs.aiways.com nrm use aiways nrm del [name] 查看本地npm源 npm get registry 创建账号并设置密码 npm adduser 创建一个npm模块 npm init 配置及添加模块代码 package.json文件中main属性配置默认输出文件 发布npm包 npm publish powered by Gitbook该文件修订时间： 2019-07-13 14:12:21 "},"Node/常见问题.html":{"url":"Node/常见问题.html","title":"常见问题","keywords":"","body":"常见问题 nodejs下使用esm 相关资源https://github.com/ChenShenhai/blog/issues/24 改变文件后缀为.mjs，使用 node --experimental-modules index.mjs运行脚本 使用loader hooks，本地创建custom-loader.mjs文件，加载自定义loader，执行import/export的*.js文件 node --experimental-modules --loader ./es/custom-loader.mjs ./es/index.js 以下是Node 9.2官方文档提供的一个自定义loader文件 import url from 'url'; import path from 'path'; import process from 'process'; // 获取所有Node原生模块名称 const builtins = new Set( Object.keys(process.binding('natives')).filter((str) => /^(?!(?:internal|node|v8)\\/)/.test(str)) ); // 配置import/export兼容的文件后缀名 const JS_EXTENSIONS = new Set(['.js', '.mjs']); // flag执行的resolve规则 export function resolve(specifier, parentModuleURL /*, defaultResolve */) { // 判断是否为Node原生模块 if (builtins.has(specifier)) { return { url: specifier, format: 'builtin' }; } // 判断是否为*.js, *.mjs文件 // 如果不是则，抛出错误 if (/^\\.{0,2}[/]/.test(specifier) !== true && !specifier.startsWith('file:')) { // For node_modules support: // return defaultResolve(specifier, parentModuleURL); throw new Error( `imports must begin with '/', './', or '../'; '${specifier}' does not`); } const resolved = new url.URL(specifier, parentModuleURL); const ext = path.extname(resolved.pathname); if (!JS_EXTENSIONS.has(ext)) { throw new Error( `Cannot load file with non-JavaScript file extension ${ext}.`); } // 如果是*.js, *.mjs文件，封装成ES6 Modules格式 return { url: resolved.href, format: 'esm' }; } 快速启动静态资源服务器 anywhere powered by Gitbook该文件修订时间： 2019-12-28 16:50:35 "},"Projects/":{"url":"Projects/","title":"Project","keywords":"","body":"Project 项目的一些经验、问题 ... powered by Gitbook该文件修订时间： 2019-04-23 17:40:11 "},"Projects/VUE-PC端管理后台开发.html":{"url":"Projects/VUE-PC端管理后台开发.html","title":"VUE-PC端管理后台开发","keywords":"","body":"VUE-PC端管理后台开发 账户权限管理系统 1. 登录/注册/刷新/登出 2. 未登录始终跳转登录 1. 页面拦截，每次进入页面调用刷新登录接口，在App.vue里写拦截逻辑 2. 接口拦截，当请求接口报错未登录时跳转登录，在接口Request的response拦截器里添加拦截逻辑 3. 不需要登录页面白名单，在拦截逻辑中忽略白名单 4. 登录及状态保存，保存至localstorage/cookie/vuex等 5. 给账户分配角色，角色配置权限 6. 权限细化到每个API，导航栏显示拥有权限的页面，vue自定义指令，给导航栏每个页面组件添加指令，指令逻辑里判断当前用户是否拥有传入权限id，没有则删除组件或设置不显示 路由系统 子路由共享布局 路由白名单 路由权限id 路由面包屑 面包屑 路由中添加面包屑参数 在layout中添加面包屑 Layout 在父路由对应的组件中添加整体布局 header、sidebar、bread crumbs、main主体 Service模块 axios default headers token传输 request/response拦截器 cancel token停止请求 Store模块 安装vuex 设计state树结构，并划分modules 代码规范 vue eslint vue-cli vue-cli-service lint 标准规范 standard eslint-config-standard eslint-plugin-standard 登录 获取token保存 路由层面的拦截，若未登录则跳转登录，在路由前置钩子里写相关逻辑 请求接口层面的拦截， 未登录跳转登录，在axios的request拦截器里写相关逻辑 powered by Gitbook该文件修订时间： 2019-05-14 23:07:24 "},"Projects/中台开发前端架构.html":{"url":"Projects/中台开发前端架构.html","title":"中台开发前端架构","keywords":"","body":"中台开发前端架构 架构导图 基础框架选型VUE vue做为前端三大框架(vue、react、angular)之一，是唯一由中国人主导的轻量型易用的渐进式js框架。 vue框架有很多优点： 易用是其突出优势，不仅有完善易读的开发文档，还有方便开发的数据双向绑定、组件化，更有配套的vue-cli命令系统，帮助快速搭建项目。 在国内有很繁荣的生态，有众多技术文献、可拿来即用的开源库。 更好的性能，更小的尺寸。它占用更少的空间，并且往往比其他框架提供更好的性能。 vue-cli构建项目 vue 官方提供了vue-cli工具进行项目的快速开发，地址：https://cli.vuejs.org/zh/guide/ 在构建项目前，应安装好一些工具： node vue/cli npm install -g @vue/cli 创建项目 vue create [name] 编译打包 npm run build 本地运行 npm run serve 添加vue插件 vue add [plugin] 可视化操作 vue ui 插件选择 项目需要安装的插件 eslint 代码检测 vue add @vue/eslint router vue add router vuex 状态管理工具 vue add vuex UI库选型element element是一款有饿了么团队开发的基于vue的桌面端组件库，有丰富的组件足以支持开发后台应用，并且拥有良好的UI及舒适的交互体验，同时可以令=灵活的配置主题，自定义外观。 使用 在项目中通过vue ui打开图形化配置界面，选择element进行安装。 http库axios axios是一款功能强大的前端http请求库，支持Promise API，提供拦截request与response的api，支持取消请求，支持防御CSRF攻击等优点。 powered by Gitbook该文件修订时间： 2019-05-24 16:21:32 "},"Projects/单页App.html":{"url":"Projects/单页App.html","title":"基于Vue的单页App","keywords":"","body":"基于Vue的单页App http 请求 去除重复请求 切换路由取消所有未完成的请求 设置请求超时时间 返回按钮的统一逻辑 嵌套路由封装关联页面的相同逻辑 表单等组件封装 切换路由后表单记忆填写内容 添加loading 调试接口 上拉加载 下拉刷新 powered by Gitbook该文件修订时间： 2019-04-10 15:12:43 "},"Projects/大屏可视化.html":{"url":"Projects/大屏可视化.html","title":"大屏可视化","keywords":"","body":"大屏可视化 调研 大屏屏幕分辨率问题 大屏屏幕分辨率不统一，可实现基于分辨率的页面整体的放大缩小 var ratio = $(window).height() / 1080; $('body').css({ transform: \"scale(\" + ratio + \")\", transformOrigin: \"left top\", backgroundSize: 100 * (window.screen.width / $(window).width() * ratio) + \"%\" + ' 100%', backgroundPosition: ($(window).width() - $('body').width() * ratio) / 2 + \"px top\", marginLeft: ($(window).width() - $('body').width() * ratio) / 2 }) 多屏拼凑的大屏宽高比例问题 多屏拼凑的大屏分辨率与屏幕尺寸比例各不相同，此时需对每个宽高比独立适配，可使用media-query进行适配 前后端通信选型 websocket ajax轮询 适配 powered by Gitbook该文件修订时间： 2019-04-22 18:28:13 "},"React/":{"url":"React/","title":"React","keywords":"","body":"React react... powered by Gitbook该文件修订时间： 2019-04-23 17:40:21 "},"React/React快速开发文档及demo.html":{"url":"React/React快速开发文档及demo.html","title":"React快速开发文档及demo","keywords":"","body":"React快速开发文档及demo powered by Gitbook该文件修订时间： 2019-03-08 14:31:38 "},"React/常见问题.html":{"url":"React/常见问题.html","title":"React 常见问题","keywords":"","body":"React 常见问题 React对象上给方法自动绑定this Combining two ES6+ features – arrow functions and property initializers 通过babel插件编译箭头函数 npm install babel-plugin-transform-class-properties --save // .babelrc { \"plugins\": [\"transform-class-properties\"] } Warning 提示 问题： Unknown props startDate, endDate, ranges, onApply on tag. Remove these props from the element. For details, see https://fb.me/react-unknown-prop 原因： 在原生节点上如div上使用了不规范的属性，可能是为了传值或者其他原因 解决办法： 在原生节点上去掉这些不规范的属性，使用data属性代替，比如需要传一个开始日期startDate，可以写成data-startDate. 问题 Warning: Each child in an array or iterator should have a unique \"key\" prop. Check the render method of CtrlGrid. See https://fb.me/react-warning-keys for more information. 原因 react规范每个数组或者迭代器中循环出来的组件或原生节点都必须添加一个唯一值的key属性，key值在此循环中唯一，以便react可以快速定位指定的组件，以此提高渲染效率 解决办法 查看报warning的页面的循环输出，给每个输出的组件或原生节点添加key属性，如果还是出现类似问题，则进一步检查同一循环内是否有key值重复. powered by Gitbook该文件修订时间： 2019-05-20 10:21:47 "},"Vue/":{"url":"Vue/","title":"Vue","keywords":"","body":"Vue vue ... powered by Gitbook该文件修订时间： 2019-04-23 17:40:30 "},"Vue/从 0 到 1 的vue项目架构.html":{"url":"Vue/从 0 到 1 的vue项目架构.html","title":"从 0 到 1 的vue项目架构","keywords":"","body":"​ 从 0 到 1 的vue项目架构 前言 vue官方提供了脚手架及vue-cli，基于此可以快速的进行开发或者创建基础的项目架构。 在构建项目前，应安装好一些工具： node yarn vue/cli yarn global add @vue/cli 创建项目 vue create [name] 编译打包 yarn build 本地运行 yarn serve 添加vue插件 vue ui vue add [plugin] 代码检测 yarn lint 设置css modules 解决问题：css的命名冲突。 在vue中使用css modules 代替 scoped的方式，有以下几种： .vue文件中 js中导入css文件 import styles from './foo.module.css' // 所有支持的预处理器都一样工作 import sassStyles from './foo.module.scss' css文件以.module.css|sass|less的形式结尾 在vue.confi.js里配置 // vue.config.js module.exports = { css: { modules: true } } typescript vue的内置方式 使用class + 渲染函数 + jsx 方式编写vue组件，拆分js、css，用ts代替js 渲染函数 .vue文件模板最终通过执行createElement转为VNode，继而构建VDom render: function (createElement) { return createElement('div', createElement('p', 'hi') ) } jsx react中的模板语言，可以在vue中使用 class hooks powered by Gitbook该文件修订时间： 2019-05-22 18:19:04 "},"Vue/反向代理.html":{"url":"Vue/反向代理.html","title":"反向代理","keywords":"","body":"反向代理 反向代理解决跨域问题 原理 开启本地服务器 api访问本地域名 本地服务器找不到相应资源，则代理请求至远程服务器，并返回数据 以此规避浏览器同源策略 实现 vue.config.js devServer: { proxy: 'http://10.100.3.104:8020' } 注意点 要实现反向代理，需将请求发送至本地服务器，而非远程服务器 powered by Gitbook该文件修订时间： 2019-04-28 18:46:12 "},"Vue/常见问题.html":{"url":"Vue/常见问题.html","title":"常见问题","keywords":"","body":"常见问题 vant组件库rem适配问题 vant组件库使用px单位，官方建议pxtorem的rootvalue值为37.5，具体效果应在项目启动前确认好。 vue scrollTop 设置无效的问题 通过url传参获取锚点元素ref名 mounted () { const _anchor = this.$route.query._anchor const offsetTop = this.$refs[_anchor].offsetTop this.$nextTick(() => { document.body.scrollTop = document.documentElement.scrollTop = offsetTop }) } vue video h5 的处理 通过ref获取video真是dom，初始隐藏，当点击播放时赋值src并执行play方法 播放 mounted () { const video = this.$refs[id] this.addListener(video) }, play () { // showLoading this.$store.commit('showLoading') const video = this.$refs[id] video.src = video.url video.play() this.show = true this.vdoplaying = id }, addListener (vdo) { vdo.addEventListener('timeupdate', () => { this.$store.commit('hideLoading') this.show = true }) vdo.addEventListener('x5videoenterfullscreen', () => { this.$store.commit('hideLoading') }) vdo.addEventListener('x5videoexitfullscreen', function () { this.$store.commit('hideLoading') this.show = false }, false) vdo.addEventListener('webkitendfullscreen', () => { this.$store.commit('hideLoading') this.show = false }, false) vdo.addEventListener('ended', () => { this.show = false }, false) } VUE 在 ios10上 报错Cannot declare a let variable twice 参考： https://github.com/mishoo/UglifyJS2/tree/harmony#mangle-options 修改生产环境webpack config中的压缩插件UglifyJsPlugin的配置，在ios10系统上不压缩文件 safari10: true new UglifyJsPlugin({ uglifyOptions: { compress: { warnings: false }, mangle: { safari10: true } }, sourceMap: config.build.productionSourceMap, parallel: true }) powered by Gitbook该文件修订时间： 2019-05-23 10:15:35 "},"Vue/预加载、懒加载在vue中的实现.html":{"url":"Vue/预加载、懒加载在vue中的实现.html","title":"预加载、懒加载在vue中的实现","keywords":"","body":"预加载、懒加载在vue中的实现 预加载 使用vue自定义命令，新增自定义命令v-preload 在created周期函数里预加载图片 const src = 'p1.png' const imgDom = new Image() imgDom.src = src imgDom.onload = () => { this.loadImg = true } 懒加载 vue-lazyload 第三方插件 可实现滚动到当前元素开始图片 自定义命令 v-lazy，在vue mounted后加载图片 此时亦可以用window.onload事件，但app会出现兼容性问题，导致图片加载不了。 import Vue from 'vue' Vue.directive('lazy', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el, { value }) { Vue.nextTick(() => (el.src = value)) } }) 预加载动态生成hash的图片 通过import的方式引进图片，则可获取到url-loader处理后的图片地址 powered by Gitbook该文件修订时间： 2019-08-22 10:34:53 "},"webpack hash解析.html":{"url":"webpack hash解析.html","title":"webpack hash解析","keywords":"","body":"webpack hash解析 为配合页面静态资源使用长效缓存，以此提升性能，webpack打包时为静态资源自动添加hash值。 静态资源包括： js文件、css文件、img文件等。 几种webpack添加hash方式 output里配置[hash] 构建相关(build-specific)的 hash，项目的compilation结果的md5值，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值 output里配置[chunkhash] chunk相关(chunk-specific)的哈希，当前chunk内容变更才会更改hash值，且不影响其他的chunk。 [contenthash] 当前文件内容相关的hash，只有当前文件改变才会更改hash值，不影响其他文件。 file-loader / url-loader 中的 [hash] 图片/ 文件 内容相关的hash，只有当前文件改变才会更改hash值，不影响其他文件。 powered by Gitbook该文件修订时间： 2019-11-19 13:46:15 "},"人机验证整理.html":{"url":"人机验证整理.html","title":"人机验证整理","keywords":"","body":"人机验证整理 相关链接： 阿里云人机验证 网易易盾行为式验证码 极验行为验证 顶象行为验证 什么是人机验证？ 当今互联网中，大量诸如垃圾注册、刷库撞库、薅羊毛等严重影响企业正常业务运作的恶意风险背后都离不开机器自动化脚本。人机验证服务在保障用户极致体验的同时有效拦截机器风险，为您提供安全可靠的业务环境。 通过生物特征判定操作计算机的是人还是机器，从而取代传统的验证方式。 常见验证方式示例 图片验证码形式 滑块验证 滑块拼图验证 点选文字/物品/图形验证 拼图验证 刮刮卡验证 验证码的前世今生 一代：标准验证码 如常见的图形验证码、语音验证码。 二代：创新验证码 第二代验证码是基于第一代验证码的核心思想（通过人类知识可以解答，而计算机难以解答的问题进行人机判断）而产生的创新的交互优化型验证码。第二代验证码基于第一代验证码的核心原理－－“人机之间知识的差异”，拓展出大量创新型验证码。如选择指定的物品，滑动拼图，点选文字等。 三代：无知识型验证码 第三代验证码最大的特点是不再基于知识进行人机判断，而是基于人类固有的生物特征以及操作的环境信息综合决策，来判断是人类还是机器。无知识型验证码最大特点即无需人类思考，从而不会打断用户操作，进而提供更好的用户体验。 如Google的ReCaptcha: 阿里巴巴的滑动验证： ​ 核心原理： ​ 1、事件采集模块，采集用户的行为信息，此部分逻辑简单，也无法自动化更新代码逻辑； ​ 2、行为数据加密模块，该部分的核心是加密算法，似乎代码逻辑自动化更新变化有足够空间。 参考：https://www.cnblogs.com/alisecurity/p/6022918.html 从Google reCAPTCHA的发展来看选择什么样的验证码最合适 powered by Gitbook该文件修订时间： 2019-11-15 10:01:04 "},"前端跨端交互sdk.html":{"url":"前端跨端交互sdk.html","title":"前端模式","keywords":"","body":"前端模式 h5 浏览器中 微信中 小程序中 app 中 小程序 交互形式 h5 app jsbridge h5 微信 微信jssdk h5 小程序中 wx.miniProgram 小程序 微信 wx对象/uni对象 powered by Gitbook该文件修订时间： 2020-02-11 10:46:10 "},"功能/":{"url":"功能/","title":"功能","keywords":"","body":"功能 一些独特的功能、工具... powered by Gitbook该文件修订时间： 2019-04-23 17:41:22 "},"功能/微信支付总结.html":{"url":"功能/微信支付总结.html","title":"微信支付总结","keywords":"","body":"微信支付总结 微信外部h5页面调起支付h5支付 调用后端接口请求支付 支付完成回跳指定页面 或者 支付页面轮询后端接口是否支付成功 注意：域名要与微信商户平台上设置的h5支付域名一致 IOS与Android中的webview需要配置跳转微信的scheme及微信回跳App 微信内的页面进行支付提供了两种方式，一个是接jssdk，一个是用微信jsbridge jsbridge的方式 用户授权获取openid(网页授权) 根据openid调用后端接口获取签名等数据 调用jsbridge的接口发起支付。 注意： 在微信商户平台（pay.weixin.qq.com）设置您的JSAPI支付支付目录为当前支付页面 在公众号后台配置当前域名为网页授权域名中 jssdk的方式 引入jssdk文件 请求后端接口获取签名 调用wx.config 调分享，调支付等等功能 注意：在公众号后台配置当前域名为网页授权域名中 powered by Gitbook该文件修订时间： 2019-04-10 13:40:41 "},"单点登录.html":{"url":"单点登录.html","title":"单点登录","keywords":"","body":"单点登录 业务平台跳转登录 https://upm-${env}.ai-ways.com/#/login?clientId=xx&_redirect=xx 参数 clientId: 客户端标识 _redirect: 回调地址 备注： 如果_redirect不为空且路径中包含'ai-ways.com'，则回跳到__redirect 如果_redirect不为空且路径中包含‘0.0.0.0’或者'localhost'且env不为prod，则回跳到__redirect 如果__redirect为空，则回跳到接口返回的默认地址： https://xxx.com/?token=xx&account=xx cookie命名 在upm进行登录后会将token及account保存到根域名下的cookie里。 upm_${env}_token upm_${env}_account 获取示例： import cookie from '@aiways/cookie' // 设置cookie cookie.setItem(sKey, sValue, vEnd, sPath, sDomain, bSecure) // get cookie cookie.getItem(sKey) env取值 dev: dev test: test pre: pre prod: prod powered by Gitbook该文件修订时间： 2020-01-16 10:57:17 "},"工具-安全-性能-调试/":{"url":"工具-安全-性能-调试/","title":"工具-安全-性能-调试","keywords":"","body":"工具-安全-性能-调试 web的安全、性能、调试及相关工具等 动态日志监控 Kibana https://www.cnblogs.com/cjsblog/p/9476813.html https://elasticsearch.cn/explore/category-4 https://github.com/elastic/kibana h5录屏 rrweb https://github.com/rrweb-io/rrweb https://juejin.im/post/5e046c166fb9a0164c7bb8bb powered by Gitbook该文件修订时间： 2020-01-08 10:24:27 "},"工具-安全-性能-调试/Arachni.html":{"url":"工具-安全-性能-调试/Arachni.html","title":"Arachni","keywords":"","body":"Arachni 概述 该工具为web漏洞扫描工具，用于扫描指定web存在的安全漏洞。 官网 使用方法 去官网下载软件包 解压缩 切换进arachni项目目录，执行命令行 Commond To use Arachni run the executables under bin/. To launch the Web interface: ```shell bin/arachni_web ``` Default account details: Administrator: E-mail address: admin@admin.admin Password: administrator User: E-mail address: user@user.user Password: regular_user For a quick scan: via the command-line interface: ```shell bin/arachni http://test.com ``` To see the available CLI options: bin/arachni -h For detailed documentation see: http://arachni-scanner.com/wiki/User-guide powered by Gitbook该文件修订时间： 2019-05-17 18:06:20 "},"工具-安全-性能-调试/Atom Plugins.html":{"url":"工具-安全-性能-调试/Atom Plugins.html","title":"Atom Plugins","keywords":"","body":"Atom Plugins activate-power-mode URL https://atom.io/packages/activate-power-mode 简介 coding时震动及火花特效 atom-beautify URL https://atom.io/packages/atom-beautify 简介 格式化代码 c/c++/css/js/html/json/jade... atom-ternjs URL https://atom.io/packages/atom-ternjs 简介 语法提示、代码补全 browser/JQ/ES6/underscore/node... autocomplete-paths URL https://atom.io/packages/autocomplete-paths 简介 路径自动补全 color-picker URL https://atom.io/packages/color-picker 简介 颜色选择器 emmet URL https://atom.io/packages/emmet 简介 emmet的atom插件 关于emmet： web开发基本工具，用于快速生成代码 相关链接： http://docs.emmet.io/ http://blog.csdn.net/left_la/article/details/13508159 git-control URL https://atom.io/packages/git-control 简介 git操作的图形用户界面 git-log URL https://atom.io/packages/git-log 简介 图表显示项目的git commits及每次commit的相关信息 git-plus URL https://atom.io/packages/git-plus 简介 在editor里进行git提交等操作 highlight-line URL https://atom.io/packages/highlight-line 简介 当前行高亮 highlight-selected URL https://atom.io/packages/highlight-selected 简介 高亮选中字符，同时所有相同字符高亮 hyperclick js-hyperclick URL https://atom.io/packages/hyperclick https://atom.io/packages/js-hyperclick 简介 cmd+click 跳转到定义，跳转到文件 language-babel （tips：该插件作者已不再支持） URL https://atom.io/packages/language-babel 简介 添加语言语法，ES6、ESNext、JSX... linter linter-eslint URL https://atom.io/packages/linter https://atom.io/packages/linter-eslint 简介 js代码校验，使用ESlint，配置文件.eslintrc.js ESlint 相关 ESLint是一个校验工具，用来避免低级错误和统一代码的风格，支持node、es6、jsx、react、vue... 相关链接 http://eslint.org/docs/rules/ markdown-preview-plus URL https://atom.io/packages/markdown-preview-plus 简介 提供markdown文件的实时预览界面 minimap URL https://atom.io/packages/minimap 简介 提供类似sublime的文件缩略图，一般在文件右上方 open-in-browser URL https://atom.io/packages/open-in-browser 简介 文件在浏览器中打开 platformio-ide-terminal URL https://atom.io/packages/platformio-ide-terminal 简介 内置终端 regex-railroad-diagram URL https://atom.io/packages/regex-railroad-diagram 简介 显示正则表达式的关系图及校验功能 script URL https://atom.io/packages/script 简介 editor中运行脚本 tree-view-git-status URL https://atom.io/packages/tree-view-git-status 简介 在目录树中显示当前git分支 ... 推荐主题 monokai URL https://atom.io/themes/monokai 简介 sublime默认主题 atom-material-ui atom-material-syntax URL https://atom.io/themes/atom-material-ui https://atom.io/themes/atom-material-syntax 简介 绿柔主题，眼睛很舒服 powered by Gitbook该文件修订时间： 2019-05-20 10:17:01 "},"工具-安全-性能-调试/charles.html":{"url":"工具-安全-性能-调试/charles.html","title":"charles","keywords":"","body":"charles 参考 https://www.axihe.com/charles/charles/tutorial.html 基本设置 安装证书 在Help -> SSL Proxying 里安装本地证书与远程手机证书 设置 Proxy 在Proxy -> Proxy Settings中设置http代理 Proxies 设置允许远程连接本地代理，及端口号 Options 设置过滤域名 macOs 设置允许mac代理 设置 SSL Proxying 在Proxy -> SSL Proxying中设置https代理 SSL Proxying 设置允许https代理的域名 设置显示在主界面的抓包记录 在Proxy -> Recording Settings -> include里添加显示抓包记录的域名，Exclude里添加不显示的域名 远程链接映射到本地服务器 概述 当请求一个链接的时候，在用charles抓包截取这个请求时，将域名替换为指定的域名(本地域名)，则该远程请求会展示本地内容。 多用于在生产环境调试本地代码，当线上项目有个bugfix时，可使用charles将线上的链接映射到本地服务器上，从而在线上环境调试bug。 设置 在Tools -> Map Remote 中设置允许远程映射，并添加映射关系。 例如 将百度映射到本地服务器。 powered by Gitbook该文件修订时间： 2019-05-14 22:26:47 "},"工具-安全-性能-调试/Git协作流程.html":{"url":"工具-安全-性能-调试/Git协作流程.html","title":"undefined","keywords":"","body":" powered by Gitbook该文件修订时间： 2019-08-07 11:27:05 "},"工具-安全-性能-调试/Gzip压缩.html":{"url":"工具-安全-性能-调试/Gzip压缩.html","title":"Gzip压缩","keywords":"","body":"Gzip压缩 服务器开启Gzip传输 浏览器支持接收Gzip格式文件 项目构建支持生成Gzip文件 powered by Gitbook该文件修订时间： 2019-08-12 15:52:23 "},"工具-安全-性能-调试/jenkins.html":{"url":"工具-安全-性能-调试/jenkins.html","title":"jenkins","keywords":"","body":"jenkins 安装部署 docker 安装 https://www.jianshu.com/p/0391e225e4a6 获取初始化密码 docker exec jenkins tail /var/jenkins_home/secrets/initialAdminPassword 使用 配合Git powered by Gitbook该文件修订时间： 2019-07-19 13:26:47 "},"工具-安全-性能-调试/JSConsole.html":{"url":"工具-安全-性能-调试/JSConsole.html","title":"JSConsole","keywords":"","body":"JSConsole （转）http://www.infoq.com/cn/news/2011/08/mobile-web-debugging （转）http://www.cnblogs.com/zichi/p/5020960.html JSConsole是一个风格和Weinre类似的工具，它更多地关注于控制台输出和代码求值。在访问JSConsole的网站的时候，用户输入“:listen”来获得带有GUID的一段JavaScript代码。这段代码需要被加入到待调试的网页中。于是，在加载网页的时候，代码将会连接到JSConsole服务器，并且根据GUID将此会话和用户的会话关联起来，于是用户浏览器中的控制台现在便已经处于待调试网页的JavaScript运行时环境中了。 JSConsole 使用方法真的很简单。 首先打开JSConsole。 接着在打开的网页输入:listen，将会得到一串 GUID 以及一对带有 src 属性的 Javascript 标签 将这个 Javascript 脚本插入到需要调试的 html 页面中 然后刷新你本地需要调试的页面（PC端或者移动端），如果是第一次打开的话，会弹出下图内容，大概意思就是告诉你现在引入了 JSConsole 的一段 js 进行调试，记得在上线时将它移除。 在打开 JSConsole 的页面便会输出 console 的内容；如果页面 JS 报错，一般情况下也能在 JSConsole 中进行定位。 这里需要提醒的是，刷新的是本地页面，而并不是 JSConsole 的页面，一旦刷新 JSConsole 的页面，便会生成一个新的 GUID，这样之前生成的就没用了，调试也就失效了。 powered by Gitbook该文件修订时间： 2019-05-20 10:21:00 "},"工具-安全-性能-调试/js保存文件工具.html":{"url":"工具-安全-性能-调试/js保存文件工具.html","title":"js保存文件工具","keywords":"","body":"js保存文件工具 file-saver 将字符串保存为自定义后缀文件 jszip 文件压缩为zip格式 CodeMirror 代码编辑器 mode addon 插件 theme powered by Gitbook该文件修订时间： 2019-07-13 09:47:37 "},"工具-安全-性能-调试/Performance.html":{"url":"工具-安全-性能-调试/Performance.html","title":"Preformance","keywords":"","body":"Preformance performance 接口 挂在window下的提供性能相关信息的接口， 融合了Performance Timeline、Navigation Timing、User Timing、Resource Timing等API 浏览器计时API： 从time origin之后到当前调用时经过的时间 time origin:https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin The time origin is a standard time which is considered to be the beginning of the current document's lifetime. It's calculated like this: If the script's global object is a Window, the time origin is determined as follows: If the current Document is the first one loaded in the Window, the time origin is the time at which the browser context was created. If during the process of unloading the previous document which was loaded in the window, a confirmation dialog was displayed to let the user confirm whether or not to leave the previous page, the time origin is the time at which the user confirmed that navigating to the new page was acceptable. If neither of the above determines the time origin, then the time origin is the time at which the navigation responsible for creating the window's current Document took place. If the script's global object is a WorkerGlobalScope (that is, the script is running as a web worker), the time origin is the moment at which the worker was created. In all other cases, the time origin is undefined. Performance 对象返回的为浏览器计时API。 Date 对象返回的为用户当前实际时间的时间戳。 Performance.timing / timeOrigin 返回的时间戳为当前实际时间的时间戳。 Performance.now() 返回DOMHighResTimeStamp类型值。 DOMHighResTimeStamp： 用于存储相对于navigationStart的时间戳，或者两个DOMHighResTimeStamps间的一段时间戳。 Performance.timing 页面加载性能时间线 navigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。 unloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。 unloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。 redirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。 redirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。 fetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。 domainLookupStart/domainLookupEnd: DNS 域名查询开始/结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 connectStart: HTTP（TCP）开始/重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。 connectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。 secureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。 requestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。 responseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。 responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。 domLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。 domInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。 domContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。 domContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。 domComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。 loadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。 loadEventEnd: load 事件的回调函数执行完毕的时间。 // 计算加载时间 function getPerformanceTiming() { var t = performance.timing var times = {} // 页面加载完成的时间，用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart // 解析 DOM 树结构的时间 times.domReady = t.domComplete - t.responseEnd // 重定向的时间 times.redirect = t.redirectEnd - t.redirectStart // DNS 查询时间 times.lookupDomain = t.domainLookupEnd - t.domainLookupStart // 读取页面第一个字节的时间 times.ttfb = t.responseStart - t.navigationStart // 资源请求加载完成的时间 times.request = t.responseEnd - t.requestStart // 执行 onload 回调函数的时间 times.loadEvent = t.loadEventEnd - t.loadEventStart // DNS 缓存时间 times.appcache = t.domainLookupStart - t.fetchStart // 卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart // TCP 建立连接完成握手的时间 times.connect = t.connectEnd - t.connectStart return times } (2) Performance.navigation redirectCount: 0 // 页面经过了多少次重定向 type: 0 0 表示正常进入页面； 1 表示通过 window.location.reload() 刷新页面； 2 表示通过浏览器前进后退进入页面； 255 表示其它方式 (3) Performance.memory jsHeapSizeLimit: 内存大小限制 totalJSHeapSize: 可使用的内存 usedJSHeapSize: JS 对象占用的内存 统计用户网速上报 powered by Gitbook该文件修订时间： 2020-03-16 17:21:55 "},"工具-安全-性能-调试/Time Slicing.html":{"url":"工具-安全-性能-调试/Time Slicing.html","title":"Time Slicing","keywords":"","body":"Time Slicing 时间切片，用于页面性能优化，避免长时间的js任务，以此来提高页面用户体验。 参考：https://github.com/berwin/Blog/issues/38 powered by Gitbook该文件修订时间： 2019-07-26 16:01:48 "},"工具-安全-性能-调试/yapi.html":{"url":"工具-安全-性能-调试/yapi.html","title":"YAPI 搭建","keywords":"","body":"YAPI 搭建 介绍 YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。 部署 官方github下载源码 https://github.com/YMFE/yapi 我的fork地址： https://github.com/zhouleiF/yapi mkdir yapi && cd yapi git clone https://github.com/YMFE/yapi.git vendors --depth=1 # 或者下载 zip 包解压到 vendors 目录 修改配置 cp vendors/config_example.json ./config.json # 复制完成后请修改相关配置 vi ./config.json 配置如下，主要配置 MongoDB 数据库，以及 Admin 账号。 { \"port\": \"3011\", \"adminAccount\": \"admin@admin.com\", \"db\": { \"servername\": \"127.0.0.1\", \"DATABASE\": \"yapi\", \"port\": 27017, \"user\": \"yapi\", \"pass\": \"yapi123\" }, \"mail\": { \"enable\": true, \"host\": \"smtp.163.com\", \"port\": 465, \"from\": \"***@163.com\", \"auth\": { \"user\": \"***@163.com\", \"pass\": \"*****\" } } } db.user 和 db.pass 是 mongodb 的用户名和密码，如果没有开启 mongo 认证功能，请删除这两个选项。 3.安装依赖 cd vendors npm install --registry https://registry.npm.taobao.org # 安装依赖 4.初始化 npm run install-server # 安装程序会初始化数据库索引和管理员账号，管理员账号名可在 config.json 配置 # 默认输出 # 初始化管理员账号成功,账号名：\"admin@admin.com\"，密码：\"ymfe.org\" 5.启动开发机 npm run dev # 启动服务器后，请访问 127.0.0.1:{config.json配置的端口}，初次运行会有个编译的过程，请耐心等候 # 127.0.0.1:3011 启动生产环境服务器 数据库 mongdb 打开数据库 cd /usr/local/mongodb/bin sudo ./mongo sudo ./mongod 关闭某个端口服务 lsof -i tcp:3000 kill -9 [id] 定制化 powered by Gitbook该文件修订时间： 2019-07-09 17:48:41 "},"工具-安全-性能-调试/创建自己的脚手架.html":{"url":"工具-安全-性能-调试/创建自己的脚手架.html","title":"创建自己的脚手架","keywords":"","body":"创建自己的脚手架 概述 类似vue-cli的，创建自己的脚手架，功能从简单到复杂，本文暂只实现脚手架生成项目统一的框架代码。 项目类型为PC端基于vue的类运营平台 bin命令 在package.json中配置bin命令，及命令运行时执行代码 \"bin\": { \"boss-build\": \"./bin/cli.js\" } 在./bin/cli.js文件中编写执行命令的脚本 commander 用commander处理用户输入的参数，及不同的参数执行不同的脚本代码 const program = require('commander') program .version('0.1.0') .option('-i, init [name]', '初始化类boss后台项目') .parse(process.argv) if (program.init) { // 此处执行 -i 时的脚本 // 此处下载平台框架代码至本地 } 通用框架代码 编写通用框架代码，类运营平台的项目基于此框架来开发，基于vue的PC端的框架，集成eslint配置、demo页面、webpack配置、element库等等。 下载通用框架代码至本地 第二步commander中 if (program.init) { // 此处执行 -i 时的脚本 // 此处下载平台框架代码至本地 } 编写下载框架的代码 const spinner = ora(`Start to init a project in ${chalk.green(projectPath)}`).start() // 获取将要构建的项目根目录 var projectPath = path.resolve(program.init) // 获取将要构建的的项目名称 var projectName = path.basename(projectPath) // 根据将要构建的项目名称创建文件夹 fs.ensureDirSync(projectName) // 获取本地模块下的demo1目录 var cwd = path.join(__dirname, '../templates/demo') // 从demo1目录中读取除node_modules目录下的所有文件并筛选处理 vfs.src(['**/*', '!node_modules/**/*'], {cwd: cwd, dot: true}) .pipe(through.obj(function (file, enc, callback) { if (!file.stat.isFile()) { return callback() } this.push(file) return callback() })) // 将从demo1目录下读取的文件流写入到之前创建的文件夹中 .pipe(vfs.dest(projectPath)) .on('end', function () { spinner.succeed('Init Success!') }) 使用 npm install boss-cli -g boss-build -i demo powered by Gitbook该文件修订时间： 2019-08-05 22:13:28 "},"工具-安全-性能-调试/安全/":{"url":"工具-安全-性能-调试/安全/","title":"安全","keywords":"","body":"安全 web安全相关 XSS/CSRF... powered by Gitbook该文件修订时间： 2019-05-17 17:54:33 "},"工具-安全-性能-调试/安全/CSRF攻击.html":{"url":"工具-安全-性能-调试/安全/CSRF攻击.html","title":"CSRF攻击","keywords":"","body":"CSRF攻击 参考 https://www.freebuf.com/articles/web/186880.html 概述 Cross-site request forgery 跨站请求伪造，第三方网站利用受害者在被攻击网站的登录凭证，冒充受害者提交操作。 通常情况下是跨域的，攻击者不能获取Cookie，但可以利用cookie信息。 预防 使用token代替cookie机制 禁止不明域名的请求 JSON WEB TOKEN (jwt) powered by Gitbook该文件修订时间： 2019-05-23 10:43:37 "},"工具-安全-性能-调试/安全/XSS攻击.html":{"url":"工具-安全-性能-调试/安全/XSS攻击.html","title":"XSS攻击","keywords":"","body":"XSS攻击 参考 https://www.freebuf.com/articles/web/185654.html#comment-257292 概念 跨站脚本攻击，常见的web攻击方式，通过向web注入恶意脚本达到获取用户敏感信息，进而危害数据安全。 常见形式 存储型 反射型 DOM型 预防 对页面中所有输入都进行转义为text 通过ajax请求数据 DOM中内联监听器，location/onclick/onerror/onload/onmouseover，标签的href属性，javascript中的eval()/setTimeout/setInterval等，都会把字符串当代码运行，传递字符串给这些API时要确保字符串的安全性。 工具 自动扫描工具寻找 XSS 漏洞，例如 Arachni、Mozilla HTTP Observatory、w3af 等 Arachni 此工具教程链接 powered by Gitbook该文件修订时间： 2019-08-02 19:43:58 "},"工具-安全-性能-调试/性能/性能.html":{"url":"工具-安全-性能-调试/性能/性能.html","title":"性能","keywords":"","body":"性能 1. 检测当前页面性能状况 powered by Gitbook该文件修订时间： 2019-09-10 16:05:32 "},"工具-安全-性能-调试/性能/性能优化.html":{"url":"工具-安全-性能-调试/性能/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 静态资源走CDN 静态资源压缩， Gzip压缩 控制http请求数量，避免过多http请求，icon使用icon font，小图片使用webpack工具转换成base64 合理使用缓存，将静态资源缓存过期时间设置为1年，当文件更新时，修改文件的hash值来更新资源 css先加载，js后加载，动态引入不用于上层内容的文件，非关键css/js文件推迟引入 路由按需加载 组件按需加载 清除注释、测试性的代码 利用webpack进行Tree-shaking，摇掉用不到的代码 懒加载首屏不需要的图片 设置preconnect, 预先建议一个connect 设置dns-prefetch，预解析dns 设置prefetch，预加载资源 设置prerender，预渲染资源 time slicing 时间切片，利用generator特性中断代码执行切割任务，加快页面渲染 避免对dom的直接操作，使用Vdom或者事件委托 服务端渲染ssr与骨架屏加载 vue中列表添加key，减少watch使用，细分组件，合理使用v-show与v-if，使用v-once、v-pre指令，使用keep-alive缓存，异步组件，Prerendering css优化：使用id选择器，使用transform， requestAnimationFrame使用代替setTimeout ssr 页面跳转，预先拉取跳转页面，等待加载完成，再跳转到新页面 减少重定向 首屏内容的js与css应内嵌网页中，其余附加功能则外部js、css延时加载。 指标 首屏展示时间 ATF： ​ 页面1s内呈现首屏（ATF）内容 https://developers.google.com/speed/docs/insights/mobile ​ 理想状态首屏资源为98k以内 白屏时间： 页面首次渲染时间： 页面首次内容渲染时间： 页面dom加载完成时间： 用户可操作时间：从页面开始加载到用户操作可响应的时间。 页面布局渲染的理想时间为200ms 每一帧时间 16.8ms http请求并发数： 6 html大小14kb以内 powered by Gitbook该文件修订时间： 2020-03-16 11:18:06 "},"工具-安全-性能-调试/性能/性能测试工具.html":{"url":"工具-安全-性能-调试/性能/性能测试工具.html","title":"性能检测工具","keywords":"","body":"性能检测工具 chrome的 Google PageSpeed Insights chrome的lighthouse 雅虎的Yellow Lab Tool GTmetrix WebPageTest All-In-One PageSpeed Test (整合以上四个) chrome performance Sitespeed.io powered by Gitbook该文件修订时间： 2019-09-10 16:36:30 "},"微信/":{"url":"微信/","title":"小程序","keywords":"","body":"小程序 小程序... powered by Gitbook该文件修订时间： 2019-04-23 17:16:53 "},"微信/小程序开发踩坑.html":{"url":"微信/小程序开发踩坑.html","title":"小程序开发踩坑","keywords":"","body":"小程序开发踩坑 采用uni-app开发框架，基于vue的一套代码运行多个终端 不能使用window/document，通过微信api获取真实dom，但没有事件的api 不能默认开启授权，只能用户主动发起授权 不能用css写背景图，只能用image标签或者背景图用base64码写css 上传、下载、请求都用微信开放api 或 uni-app开发api 真机上发起请求需在后台配置好服务器域名 用户敏感信息如openid、手机号等需要后端解密 有区别于vue的新增生命周期 js里路径@表示src，css里路径~@表示src 开放api需注意必填项，如未传必填，则调用失效 可用vuex状态管理 没有 FormData对象 支持的基础类库 保存图片需在后台配置downloadFile合法域名 上传图片需在后台配置uploadFile合法域名 保存图片需调用wx api 上传图片需要调用wx api 后台 服务器域名配置每月 4次，个数不限 powered by Gitbook该文件修订时间： 2020-01-08 15:50:12 "},"微信/微信公众号.html":{"url":"微信/微信公众号.html","title":"微信公众号","keywords":"","body":"微信公众号 业务域名 去掉页面顶部不安全提示 js接口安全域名 在此域名下的页面可调用微信开放的js接口 网页授权域名 此域名可获得微信授权 powered by Gitbook该文件修订时间： 2019-12-25 11:20:40 "},"微信/微信小程序开发方案调研.html":{"url":"微信/微信小程序开发方案调研.html","title":"微信小程序开发方案调研","keywords":"","body":"微信小程序开发方案调研 mpvue uni-app WePY 总结 mpvue 查阅地址：https://github.com/Meituan-Dianping/mpvue 简介：美团点评推出的基于vue的扩展框架，扩展了vue的小程序开发能力，可以使用vue快速开发微信、百度、今日头条、支付宝等小程序，最终编译成小程序可识别代码。 用法：使用vue-cli3.0版本创建mpvue项目 $ vue init mpvue/mpvue-quickstart my-project $ cd my-project $ yarn run dev 生成dist目录里存放小程序相关代码 uni-app 查阅地址：https://github.com/dcloudio/uni-app 简介：HbuilderX编辑器推出的使用vue开发的跨平台框架，开发一套代码，可编译到ios、Android、H5、小程序多个平台。其中编译到小程序时借鉴了mpvue框架，同时在H5平台完整模拟实现了小程序的逻辑层与视图层，具体分析文章https://zhuanlan.zhihu.com/p/52933718 用法： HbuilderX编辑器一键创建项目，一键发布项目 vue-cli3.0创建项目 $ vue create -p dcloudio/uni-preset-vue my-project $ yarn run dev h5/mp-weixin $ yarn run build h5/mp-weixin WePY 查阅地址：https://github.com/Tencent/wepy 简介：腾讯官方推出的一款让小程序支持组件化开发的框架，类vue的开发风格。 用法： $ yarn global add wepy-cli $ wepy init standard myproject $ cd myproject $ wepy build —watch Taro 查阅地址：https://github.com/NervJS/taro 简介：京东团队推出的一款使用react开发小程序的write once, run everywhere 框架。 总结 目前较为靠谱的则是基于vue的mpvue框架，而uni-app又基于mpvue完善了发布h5的功能，因此目前开发方案推荐两种： 使用uni-app或者直接在hbuilder编辑器里开发小程序 使用腾讯官方推出的新框架，语法类似vue，更多的学习成本，但此方案并不能发布h5 powered by Gitbook该文件修订时间： 2019-05-20 11:15:50 "},"微前端.html":{"url":"微前端.html","title":"基于web components的微前端系统","keywords":"","body":"基于web components的微前端系统 发布web components 布局组件、内容组件、应用组件 应用添加/删除web components 对三类组件分别做不同处理 路由分发系统 注册路由，对应内容组件，是否显示布局组件 选择布局组件，每个应用只能有一个布局组件 删除路由，注销组件 应用组件合并策略：合并路由及内容组件，舍弃布局组件。 加载组件资源 加载布局组件资源 ->切换路由 ->获取加载资源列表 -> 加载对应资源 -> 渲染 难点 路由分发系统的实现 应用组件的合并策略 状态管理及共享 template引入及编译 powered by Gitbook该文件修订时间： 2019-12-31 17:29:08 "},"概念集合.html":{"url":"概念集合.html","title":"概念集合","keywords":"","body":"概念集合 CI Continuous Integration 的缩写，持续集成。 gitlab CI 与gitlab配合实现每次提交自动构建功能。 TDD Test-Driven Development，测试驱动开发。 Tree-shaking roll-up webpack 等构件工具的摇数优化 DevOps BFF backend for frontends ELK ELK = Elasticsearch, Logstash, Kibana 是一套实时数据收集，存储，索引，检索，统计分析及可视化的解决方案。最新版本已经改名为Elastic Stack，并新增了Beats项目。 vasSonic 腾讯轻量级高性能hybrid框架 powered by Gitbook该文件修订时间： 2020-01-15 19:55:43 "},"正则表达式.html":{"url":"正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 修饰符 模式 元字符 量词 捕获 RegExp对象 使用 str.search(reg) str.replace(reg, '') reg.test(str) exec compile powered by Gitbook该文件修订时间： 2019-08-21 11:06:17 "},"问题集.html":{"url":"问题集.html","title":"问题集","keywords":"","body":"问题集 React常见问题 /React/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html Vue常见问题 /Vue/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html input['text']无法在safari输入的问题 给input加css input { -webkit-user-select:text !important; } input在android中被键盘挡住的问题 focus (e) { e.target.scrollIntoViewIfNeeded() } input在android webview中自动提示导致页面错乱的问题 禁止自动提示功能 input在ios webview中被键盘挡住的问题 focus (e) { const winHeight = window.innerHeight const targetTop = e.target.offsetTop const scrollH = targetTop - winHeight / 4 if (document.documentElement.scrollTop iframe通信 获取ifram内window const frameWin = this.frameWin = window.document.getElementsByTagName('iframe')[0].contentWindow frameWin && (frameWin.onload = () => { const doc = frameWin.document const arr = [...doc.querySelectorAll('.orderbtn')] //... }) iframe在移动端不能正确监听滚动的问题 在外部页面模拟引用页面的滚动 window.onscroll = this.scroll scroll () { const doc = this.frameWin.document const arr = [...doc.querySelectorAll('.sections')] const winHeight = window.innerHeight arr.forEach(e => { if (!e.style.opacity) { const targetTop = e.offsetTop const scrollH = targetTop - winHeight / 5 * 4 if (window.scrollY >= scrollH) { e.style.opacity = 1 e.style.transition = '.5s' } } }) }, window.onload 在app里触发时机不对的问题 用其他方案代替，比如vue的mounted，vue的nextTick等 编译后的文件存在es6代码导致报错 原因：大部分情况是由于引入的npm库文件存在es6代码导致 解决：有以下几种方式 导入@babel/poplyfill 文件 针对有es6代码文件的包进行编译，两种方式 在babel-loader里include需要编译的库文件 基于vue-cli3的项目，将需要编译的库添加到vue.config.js里transpileDependencies 选项 基于vue-cli项目，在babel-config里使用 @vue/babel-preset-app 的 polyfills 选项预包含所需要的 polyfill // babel.config.js module.exports = { presets: [ ['@vue/app', { polyfills: [ 'es6.promise', 'es6.symbol' ] }] ] } ios webview有时url会自动改到首页的问题 原因：经排查，系webviewjsbridge未成功注入window前就加载页面调用jsbridge的方法，导致问题，出现url被改变的情况。 解决：在调用jsbridge前保证WebViewJavascriptBridge已经注入到window中。 富文本编辑禁止外链图片复制 基于quill editor，判断复制内容，若为img，且图片链接域名不正确，则报错 powered by Gitbook该文件修订时间： 2020-01-08 13:41:25 "}}